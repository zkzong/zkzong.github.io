---
title: Java多线程编程核心技术
date: 2019-04-19
categories: 多线程
---

## 第1章 Java多线程技能

1. 在Java中有以下3种方法可以终止正在运行的线程：
1）使用退出标志，使线程正常退出，也就是当run方法完成后线程终止。
2）使用stop方法强行终止线程，但是不推荐使用这个方法，因为stop和suspend及resume一样，都是作废过期的方法，使用它们可能产生不可预料的结果。
3）使用interrupt方法中断线程。
调用interrupt()方法仅仅是在当前线程中打了一个停止的标记，并不是真的停止线程。
2. 判断线程是否是停止状态
1）this.interrupted()：测试当前线程是否已经中断。
2）this.isInterrupted()：测试线程能够是否已经中断。
interrupted()方法具有清除状态的功能。
3. yield方法
yield()方法的作用是放弃当前的CPU资源，将他让给其他的任务去占用CPU执行时间。但放弃的时间不确定，有可能刚刚放弃，马上又获得CPU时间片。
4. 线程的优先级
在Java中，线程的优先级具有继承性，比如A线程启动B线程，则B线程的优先级与A是一样的。

## 第2章 对象及变量的并发访问

### 2.1 synchronized同步方法

1. 方法内的变量为线程安全，这是方法内部的变量是私有的特性造成的。
2. 实例变量非线程安全。
3. 在两个线程访问同一个对象中的同步方法时一定是线程安全的。
4. 关键字synchronized取得的锁都是对象锁，而不是把一段代码或方法当作锁。
5. 调用用关键字synchronized声明的方法一定是排队运行的。另外需要牢牢记住“共享”这两个字，只有共享资源的读写访问才需要同步化，如果不是共享资源，那么根本就没有同步的必要。
6. 当A线程调用anyObject对象加入synchronized关键字的X方法时，A线程就获得了X方法锁，更准确地讲，是获得了对象的锁，所以其他线程必须等A线程执行完毕才可以调用X方法，但B线程可以随意调用其他的非synchronized同步方法。当A线程调用anyObject对象加入synchronized关键字的X方法时，A线程就获得了X方法所在对象的锁，所以其他线程必须等A线程执行完毕才可以调用X方法，而B线程如果调用了synchronized关键字的非X方法时，必须等A线程将X方法执行完，也就是释放对象锁后才可以调用。这时A线程已经执行了一个完整的任务，也就是说username和password这两个实例变量已经同时被赋值，不存在脏读的基本环境。
7. synchronized锁重入：关键字synchronized拥有锁重入的功能，也就是在使用synchronized时，当一个线程得到一个对象锁后，再次请求此对象锁时是可以再次得到该对象的锁的。
8. 当一个线程执行的代码出现异常时，其所持有的锁会自动释放。
9. 同步不可以继承。

### 2.2 synchronized同步语句块

用关键字synchronized声明方法在某些情况下是有弊端的，比如A线程调用同步方法执行一个长时间的任务，那么B线程则必须等待比较长时间。在这样的情况下可以使用synchronized同步语句块来解决。

在使用同步synchronized(this)代码块时需要注意的是，当一个线程访问object的一个synchronized(this)同步代码块时，其他线程对同一个object中所有其他synchronized(this)同步代码块的访问将被阻塞，这说明synchronized使用的“对象监视器”是一个。

和synchronized方法一样，synchronized(this)代码块也是锁定当前对象的。

多个线程调用同一个对象中的不同名称的synchronized同步方法或synchronized(this)同步代码块时，调用的效果就是按顺序执行，也就是同步的，阻塞的。

这说明synchronized同步方法或synchronized(this)同步代码块分别有两种作用。

（1）synchronized同步方法
1）对其他synchronized同步方法或synchronized(this)同步代码块调用呈阻塞状态。
2）同一时间只有一个线程可以执行synchronized同步方法中的代码。
（2）synchronized(this)同步代码块
1）对其他synchronized同步方法或synchronized(this)同步代码块调用呈阻塞状态。
2）同一时间只有一个线程可以执行synchronized同步代码块中的代码。

如果在一个类中有很多个synchronized方法，这时虽然能实现同步，但会受到阻塞，所以影响运行效率；但如果使用同步代码块锁非this对象，则synchronized(非this)代码块中的程序与同步方法是异步的，不与其他锁this同步方法争抢this锁，则可大大提高运行效率。

使用“synchronized(非this对象x)同步代码块”格式进行同步操作时，对象监视器必须是同一个对象。如果不是同一个对象监视器，运行的结果就是异步调用了，就会交叉运行。

1）当多个线程同时执行synchronized(X){}同步代码块时呈同步效果。
2）当其他线程执行x对象中synchronized同步方法时呈同步效果。
3）当其他线程执行x对象方法里面的synchronized(this)代码块时也呈现同步效果。
但需要注意：如果其他线程调用不加synchronized关键字的方法时，还是异步调用。

关键字volatile的主要作用是使变量在多个线程间可见。

关键字volatile的作用是强制从公共堆栈中取得变量的值，而不是从线程私有数据栈中取得变量的值。

synchronized和volatile比较：

+ 关键字volatile是线程同步的轻量级实现，所以volatile性能肯定比synchronized要好，并且volatile只能修饰于变量，而synchronized可以修饰方法，以及代码块。
+ 多线程访问volatile不会发生阻塞，而synchronized会出现阻塞。
+ volatile能保证数据的可见性，但不能保证原子性；而synchronized可以保证原子性，也可以间接保证可见性，因为它会将私有内存和公共内存中的数据做同步。
+ 关键字volatile解决的是变量在多个线程之间的可见性；而synchronized关键字解决的是多个线程之间访问资源的同步性。

## 第3章 线程间通信

方法wait()的作用是使当前执行代码的线程进行等待，wait()方法是Object类的方法，该方法用来将当前线程置入“预执行队列”中，并且在wait()所在的代码行处停止执行，直到接到通知或被中断为止。**在调用wait()之前，线程必须获得该对象的对象级别锁，即只能在同步方法或同步块中调用wait()方法。**在执行wait()方法后，当前线程释放锁。在从wait()返回前，线程与其他线程竞争重新获得锁。如果调用wait()时没有持有适当的锁，则抛出IllegalMonitorStateException，它是RuntimeException的一个子类，因此，不需要try-catch语句进行捕获异常。
**方法notify()也要在同步方法或同步块中调用，即在调用前，线程也必须获得该对象的对象级别锁。**如果调用notify()时灭有持有适当的锁，也会抛出IllegalMonitorStateException。该方法用来通知那些可能等待该对象的对象锁的其他线程，对其发出通知notify，并使它等待获取该对象的对象锁。需要说明的是，在执行notify()方法后，当前线程不会马上释放该对象锁，呈wait状态的线程也并不能马上获取该对象锁，要等到执行notify()方法的线程将程序执行完，也就是退出synchronized代码块后，当前线程才会释放锁，而呈wait状态所在的线程才可以获取该对象锁。当第一个获得了该对象锁的wait线程运行完毕以后，它会释放掉该对象锁，此时如果该对象没有再次使用notify语句，则即便该对象已经空闲，其他wait状态等待的线程由于没有得到该对象的通知，还会继续阻塞在wait状态，直到这个对象发出一个notify或nofityAll。
用一句话来总结一下wait和notify：wait使线程停止运行，而notify使停止的线程继续运行。

关键字synchronized可以将任何一个Object对象作为同步对象来看待，而Java为每个Object都实现了wait()和notify()方法，它们必须用在被synchronized同步的Object的临界区内。通过调用wait()方法可以使处于临界区内的线程进入等待状态，同时释放被同步对象的锁。而notify操作可以唤醒一个因调用了wait操作而处于阻塞状态中的线程，使其进入就绪状态。被重新唤醒的线程会试图重新获得临界区的控制权，也就是锁，并继续执行临界区内wait之后的代码。如果发出notify操作时没有处于阻塞状态中的线程，那么该命令会被忽略。
wait()方法可以使调用该方法的线程释放共享资源的锁，然后从运行状态退出，进入等待队列，直到被再次唤醒。
notify()方法可以随机唤醒等待队列中等待同一共享资源的“一个”线程，并使该线程退出等待队列，进入可运行状态，也就是notify()方法仅通知“一个”线程。
notifyAll()方法可以使所有正在等待队列中等待同一共享资源的“全部”线程从等待状态退出，进入可运行状态。此时，优先级最高的那个线程最先执行，但也有可能是随机执行，因为这要取决于JVM虚拟机的实现。

当方法wait()被执行后，锁被自动释放，但执行完notify()方法，锁却不自动释放。

带一个参数的wait(long)方法的功能是等待某一时间内是否有线程对锁进行唤醒，如果超过这个时间则自动唤醒。
